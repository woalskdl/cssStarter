div {
  /* width: 200px; */
  /* height: 100px; */
	background-color: orange;
  border: #000 1px solid;
  margin: 10px 10px;
}
span {
  background-color: aquamarine;
  margin: 10px 10px;
}

/* 선택자 */
/* 인접 형제 선택자 - 선택자 첫번째 다음 형제 요소 하나를 선택 */
.orange + li {
  /* orange 클래스 요소의 다음 형제 요소 하나를 선택 */
  color: red;
}

/* 일반 형제 선택자 - 선택자 첫번째 다음 형제 모두 선택 */
.orange ~ li {
  /* orange 클래스 요소 뒤에오는 모든 형제 요소 선택 */
  color: red;
}

/* 가상 클래스 */
.orange:hover {
  color: black;
  /* 종류 */
  /* active : 마우스를 클릭하고 있는 동안 */
  /* focus : 포커스하는 동안 (포커스가 가능한 요소에 대해 - div 같은거는 attribute에 tabindex="-1" 을 넣으면 포커스 가능) */
}

.checkList {
  background: #f2f2f2;
}

/* 해당 선택자가 형제 요소 중 첫째라면 선택 (그 중 첫번째를 선택하는게 아님) */
.checkList span:first-child {
  color: red;
}

/* 해당 선택자가 형제 요소 중 막내라면 선택 (그 중 막내를 선택하는게 아님) */
.checkList div:last-child {
  color: red;
}

/* 선택자 형제 요소 중 n째라면 선택 - 배수 및 짝수 홀수 가능 */
.checkList li:nth-child(3n + 1) {
  text-decoration: underline;
}

/* 선택자 형제 요소 중 n째라면 선택 - 몇번째부터 선택 가능  */
.checkList li:nth-child(n + 2) {
  font-weight: 1000;
}

/* 선택자가 아닌 요소 선택  */
.checkList li:not(.check) {
  background: #000;
}

/* 가상 요소 선택자 */
/* 선택자 요소 내부 앞에 내용 삽입 */
.checkList::before {
  content: '리스트 앞 입니다.';
}

/* 선택자 요소 내부 뒤에 내용 삽입 */
.checkList::after {
  content: '리스트 뒤 입니다.';
}

/* 속성 선택자 */
.checkList [disabled] {
  background: royalblue;
}

/* ================================== */
/* 상속되는 속성은 대부분 글자와 관련된 요소 */

/* 단위 */
div.something {
  width: 1px;
  width: 1%;
  width: 1em; /* 요소의 글꼴 크기 - ex. 기본 글꼴 크기가 10px이라면 1em = 10px */
  width: 1rem; /* 루트 요소(html, 최상위 요소)의 글꼴 크기 */
  width: 1vw; /* 뷰포트 가로 너비의 백분율 */
  width: 1vh; /* 뷰포트 세로 너비의 백분율 */
}

/* 여백 */
/* margin : 외부 여백 */
div.margin {
  margin: 10px 20px; /* 상하, 좌우 */
  margin: 10px 20px 30px; /* 상 좌우 하 (위에서부터 아래로) */
  margin: 10px 20px 30px 40px; /* 상 우 하 좌 (시계방향) */
}

/* padding : 내부 여백 - 요소 자체의 크기도 늘어난다. */

/* border : 선 두께 선 종류 선 색상 - 이 순서로 입력하는게 좋다. / 요소의 크기도 늘어난다. */
div.border {
  border: 1px 2px 1px solid black transparent;  /* 두께, 종류, 색상도 상하좌우 동일하게 입력 가능 / transparent 투명 */
}

/* box-sizing*/
div.box-sizing {
  box-sizing: border-box; /* 명시된 가로 세로 너비가 테두리를 고려하여 적용 (테두리에 의해 요소가 커지지 않도록) */
  box-sizing: content-box; /* 명시된 가로 세로 너비가 내용을 고려하여 적용 (default) */
}

/* overflow - default : visible*/
div.overflow {
  overflow: hidden; /* 숨기기 */
  overflow: scroll; /* 무조건 스크롤 */
  overflow: auto;   /* 넘치면 스크롤 */
}

/* display */
div.display {
  display: inline-block;  /* inline(글자)이지만 가로, 세로 값을 지정할 수 있음 */
  display: flex;  /* 1차원 레이아웃 - 수직 정렬 */
  display: grid;  /* 2차원 레이아웃 */
}

/* font-family - 글꼴 후보 지정, 글꼴 계열은 필수 지정 > 후보 중 가능한 가장 첫번째 글꼴 사용 (브라우저 환경에 따라) */
/* 폰트명에 띄워쓰기가 있으면 ""로 감싸기 */

/* 배치 - absolute, fixed 가 지정된 요소는 display 속성이 block으로 변경된다. */
div.position {
  position: static;   /* 기준 없음 - default */
  position: relative; /* 요소 자신을 기준 
  - position 설정하지 않았다면 자기가 원래 있었던 곳을 기준 
  > 실제로 요소는 원래 위치에 있지만, 보여지는 것만 이동 
  > 위치를 조정하는데 쓰이기보단 absolute의 부모로 지정하는데 많이 사용 */
  position: absolute; /* 위치 상 부모 요소 기준 
  - 부모 요소를 기준으로 하기 때문에 위치가 부모 요소를 기준으로 하며 붕뜨는 개념으로 자리잡음. 
  > 형제 요소와의 위치 상호작용이 무너진다. 
  > 위치 상 부모 요소이며, position을 가지는 부모 요소가 기준이다. 따라서 실제 HTML구조 상 부모가 아닐 수도 있다.
  > 부모 요소에 position : relative 가 있는 것을 기준 / static(default) 값은 기준이 없기 때문에 위치가 없는 것 */
  position: fixed;    /* 뷰포트 기준 - 헤더, 툴바 등을 표현하는데 많이 사용됨. 스크롤과 무관하게 고정 */

  /* 기준을 잡은 뒤 위치값을 설정한다. 음수도 사용 가능 */
  top: auto;      /* 위에서부터 얼마나 떨어졌나 */
  bottom: auto;   /* 아래에서부터 얼마나 떨어졌나 */
  left: auto;     /* 왼쪽에서부터 얼마나 떨어졌나 */
  right: auto;    /* 오른쪽에서부터 얼마나 떨어졌나 */
  z-index: auto;
  /* 요소 쌓임 순서 */
  /* 1. 요소에 position 속상 값이 있는 경우 더 위에 쌓인다. 기존 static 제외 */
  /* 2. position 속성값과 z-index가 같으면 HTML 구조 상 다음에 있는 요소가 위에 쌓임 */
  /* z-index가 있어도 position값이 없으면 적용 안됨 */
}